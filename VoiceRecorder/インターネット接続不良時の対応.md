# インターネット接続不良時の対応 - プログラム修正計画書

## 1. 概要

### 1.1 目的
インターネット接続が不安定な環境（繋がったり切れたり、遅延したり速度が戻ったり）でも、文字起こしの抜けを最小限に抑え、最終的に正しい順序で完全な文字起こし結果を得られるようにする。

### 1.2 解決すべき問題
1. **ネット不安定時の文字起こし失敗**: 現在はリトライ対象が限定的で、ネットワークエラーでチャンクが失われる
2. **順序の乱れ**: 並列処理のため、後から成功したチャンクが先に表示される
3. **大量リトライによるフリーズ**: 長時間オフライン後にネット復帰すると、大量のリトライが発生
4. **オフラインのまま録音終了**: 文字起こしができないまま終了した場合の救済手段がない

### 1.3 解決方針
3段階のモードを導入し、ネットワーク状態に応じて自動的に切り替える。

---

## 2. モード設計

### 2.1 モード定義

```csharp
public enum TranscriptionMode
{
    Realtime,   // 通常モード：リアルタイム文字起こし
    Unstable,   // 不安定モード：チャンクを保持しつつリトライ
    BatchOnly   // まとめて処理モード：録音停止時に一括処理
}
```

### 2.2 モード遷移図

```
                      成功（キュー空）
    ┌─────────────────────────────────────┐
    │                                     │
    ▼                                     │
┌──────────┐  エラー発生  ┌──────────────┐  │
│ Realtime │────────────→│  Unstable    │──┘
│ 通常     │              │  不安定      │
└──────────┘              └──────────────┘
                               │
                               │ 10分経過
                               ▼
                          ┌──────────────┐
                          │  BatchOnly   │
                          │  まとめて処理 │
                          └──────────────┘
                               │
                               │ 録音停止
                               ▼
                    ┌─────────────────────────┐
                    │ 録音ファイル全体を       │
                    │ 文字起こし → 要約       │
                    └─────────────────────────┘
                               │
                               │ APIエラー（オフライン継続）
                               ▼
                    ┌─────────────────────────┐
                    │ エラーメッセージ表示     │
                    │ 「音声ファイル選択から   │
                    │  再処理してください」    │
                    └─────────────────────────┘
```

### 2.3 各モードの動作

| モード | チャンク処理 | UI表示 | 備考 |
|--------|-------------|--------|------|
| Realtime | 即時API送信 | リアルタイム文字起こし表示 | 従来通り |
| Unstable | キューに保持＋リトライ | 変更なし（文字起こし継続表示） | エラー発生チャンクも保持 |
| BatchOnly | 処理しない | 「まとめて処理します」表示 | 録音ファイルのみ保持 |

---

## 3. 詳細設計

### 3.1 状態管理用フィールド（MainWindow.xaml.cs に追加）

```csharp
// === インターネット接続不良時の対応 ===
private enum TranscriptionMode { Realtime, Unstable, BatchOnly }
private TranscriptionMode _transcriptionMode = TranscriptionMode.Realtime;

// 保持キュー（タイムスタンプ順でソート）
private readonly SortedList<DateTime, (RecordingSession session, byte[] audio)> 
    _pendingChunks = new();
private readonly object _pendingChunksLock = new();

// 不安定モード開始時刻
private DateTime _unstableModeStartedAt = DateTime.MinValue;

// リトライ用タイマー
private DispatcherTimer? _chunkRetryTimer;

// 閾値設定
private const int BATCH_THRESHOLD_MINUTES = 10;  // まとめて処理モードへの切り替え閾値
private const int RETRY_INTERVAL_SECONDS = 5;    // リトライ間隔
private const int MAX_PENDING_CHUNKS = 50;       // 保持キュー上限（約10分分）
```

### 3.2 ProcessChunkAsync の修正

```csharp
private async Task ProcessChunkAsync(RecordingSession session, byte[] audioData)
{
    DateTime timestamp = DateTime.UtcNow;

    // === BatchOnlyモードの場合は何もしない（録音ファイルのみ保持） ===
    if (_transcriptionMode == TranscriptionMode.BatchOnly)
    {
        Debug.WriteLine($"📦 BatchOnlyモード: チャンクをスキップ ({audioData.Length} bytes)");
        return;
    }

    // === Unstableモードの場合は、まずキューに追加 ===
    if (_transcriptionMode == TranscriptionMode.Unstable)
    {
        AddToQueue(timestamp, session, audioData);
        EnsureRetryTimerRunning();
        return;
    }

    // === Realtimeモード: API呼び出し ===
    await _uploadSemaphore.WaitAsync();
    try
    {
        string chunkText = await SpeechToText.StartFastTranscriptionWithRetry(
            audioData, $"chunk_{timestamp.Ticks}.wav");

        if (!string.IsNullOrWhiteSpace(chunkText))
        {
            await this.Dispatcher.InvokeAsync(() =>
            {
                session.AppendTranscript(chunkText);
                if (session == CurrentSession && RecordingSession.CurrentPerformanceMode != 3)
                {
                    SummaryText = "🎤 録音中...\n\n" + session.AccumulatedTranscript;
                }
            });
        }
    }
    catch (Exception ex)
    {
        Debug.WriteLine($"❌ チャンク処理失敗: {ex.Message}");

        // ★ 失敗したチャンク自体をキューに追加 ★
        AddToQueue(timestamp, session, audioData);

        // ★ Unstableモードに移行 ★
        if (_transcriptionMode == TranscriptionMode.Realtime)
        {
            _transcriptionMode = TranscriptionMode.Unstable;
            _unstableModeStartedAt = DateTime.UtcNow;
            Debug.WriteLine("🔄 Unstableモードに移行");
            LogToFile("[モード切替] Realtime → Unstable");
            EnsureRetryTimerRunning();
        }
    }
    finally
    {
        _uploadSemaphore.Release();
    }
}
```

### 3.3 キュー操作メソッド

```csharp
private void AddToQueue(DateTime timestamp, RecordingSession session, byte[] audioData)
{
    lock (_pendingChunksLock)
    {
        // キュー上限チェック（古いものを破棄しない - メモリ許容範囲内）
        if (_pendingChunks.Count >= MAX_PENDING_CHUNKS)
        {
            Debug.WriteLine($"⚠️ 保持キュー上限到達 ({MAX_PENDING_CHUNKS}個)");
            // 上限到達時はBatchOnlyモードへ強制移行
            SwitchToBatchOnlyMode();
            return;
        }

        // 同一タイムスタンプの重複を防ぐ
        while (_pendingChunks.ContainsKey(timestamp))
        {
            timestamp = timestamp.AddTicks(1);
        }
        _pendingChunks.Add(timestamp, (session, audioData));
        Debug.WriteLine($"📥 キューに追加: {_pendingChunks.Count}個");
    }
}

private void EnsureRetryTimerRunning()
{
    if (_chunkRetryTimer == null)
    {
        _chunkRetryTimer = new DispatcherTimer
        {
            Interval = TimeSpan.FromSeconds(RETRY_INTERVAL_SECONDS)
        };
        _chunkRetryTimer.Tick += ChunkRetryTimer_Tick;
    }
    if (!_chunkRetryTimer.IsEnabled)
    {
        _chunkRetryTimer.Start();
        Debug.WriteLine("⏱️ リトライタイマー開始");
    }
}
```

### 3.4 リトライタイマー処理

```csharp
private async void ChunkRetryTimer_Tick(object? sender, EventArgs e)
{
    // 10分経過チェック → BatchOnlyモードへ
    if (_transcriptionMode == TranscriptionMode.Unstable &&
        (DateTime.UtcNow - _unstableModeStartedAt).TotalMinutes >= BATCH_THRESHOLD_MINUTES)
    {
        SwitchToBatchOnlyMode();
        return;
    }

    // キューから最も古いチャンクを取得
    (DateTime timestamp, (RecordingSession session, byte[] audio) chunk)? oldest = null;
    lock (_pendingChunksLock)
    {
        if (_pendingChunks.Count > 0)
        {
            var key = _pendingChunks.Keys[0];
            oldest = (key, _pendingChunks[key]);
        }
    }

    if (oldest == null)
    {
        // キューが空 → Realtimeモードに復帰
        _transcriptionMode = TranscriptionMode.Realtime;
        _chunkRetryTimer?.Stop();
        Debug.WriteLine("✅ Realtimeモードに復帰（キュー空）");
        LogToFile("[モード切替] Unstable → Realtime（復帰）");
        return;
    }

    // リトライ
    bool acquired = await _uploadSemaphore.WaitAsync(TimeSpan.FromSeconds(1));
    if (!acquired) return; // セマフォ取得失敗は次回リトライ

    try
    {
        string chunkText = await SpeechToText.StartFastTranscriptionWithRetry(
            oldest.Value.chunk.audio,
            $"chunk_retry_{oldest.Value.timestamp.Ticks}.wav");

        // 成功 → キューから削除、結果を追記
        lock (_pendingChunksLock)
        {
            _pendingChunks.Remove(oldest.Value.timestamp);
        }

        if (!string.IsNullOrWhiteSpace(chunkText))
        {
            await this.Dispatcher.InvokeAsync(() =>
            {
                oldest.Value.chunk.session.AppendTranscript(chunkText);
                if (oldest.Value.chunk.session == CurrentSession &&
                    RecordingSession.CurrentPerformanceMode != 3)
                {
                    SummaryText = "🎤 録音中...\n\n" +
                        oldest.Value.chunk.session.AccumulatedTranscript;
                }
            });
        }

        Debug.WriteLine($"✅ リトライ成功: 残り{_pendingChunks.Count}個");
    }
    catch (Exception ex)
    {
        Debug.WriteLine($"⚠️ リトライ失敗: {ex.Message}");
        // 失敗 → キューに残す（次回リトライ）
    }
    finally
    {
        _uploadSemaphore.Release();
    }
}
```

### 3.5 BatchOnlyモードへの切り替え

```csharp
private void SwitchToBatchOnlyMode()
{
    _transcriptionMode = TranscriptionMode.BatchOnly;
    _chunkRetryTimer?.Stop();

    // キューをクリア（メモリ解放）
    lock (_pendingChunksLock)
    {
        int count = _pendingChunks.Count;
        _pendingChunks.Clear();
        Debug.WriteLine($"🗑️ キューをクリア: {count}個のチャンクを破棄");
    }

    // UIを変更
    this.Dispatcher.Invoke(() =>
    {
        SummaryText = "⚠️ インターネット接続が不安定なため、\n録音停止時にまとめて処理します";
    });

    Debug.WriteLine("📦 BatchOnlyモードに移行");
    LogToFile("[モード切替] Unstable → BatchOnly（10分経過）");
}
```

### 3.6 録音停止時の処理（StopRecordingAsync の修正）

```csharp
// StopRecordingAsync 内の要約処理部分を修正

// BatchOnlyモードの場合は録音ファイル全体を文字起こし
if (_transcriptionMode == TranscriptionMode.BatchOnly)
{
    Debug.WriteLine("📦 BatchOnlyモード: 録音ファイル全体を文字起こし開始");
    StatusText.Text = "📝 文字起こし中...（まとめて処理）";

    try
    {
        // 録音ファイル全体を文字起こし
        string fullTranscript = await TranscribeAllRecordingFilesAsync(session);

        if (string.IsNullOrWhiteSpace(fullTranscript))
        {
            // 文字起こし失敗（オフライン継続）
            await ShowOfflineErrorMessageAsync(session);
            return;
        }

        // セッションに文字起こし結果を設定
        session.SetFullTranscript(fullTranscript);

        // 要約処理へ
        _ = ProcessSummaryAsync(session, session.CurrentTextFilePath, elapsedSeconds);
    }
    catch (Exception ex)
    {
        Debug.WriteLine($"❌ まとめて処理失敗: {ex.Message}");
        await ShowOfflineErrorMessageAsync(session);
    }
}
else
{
    // 通常の処理（既存コード）
    _ = ProcessSummaryAsync(session, textFilePath, elapsedSeconds);
}

// モードをリセット
_transcriptionMode = TranscriptionMode.Realtime;
```

### 3.7 録音ファイル全体の文字起こし

```csharp
private async Task<string> TranscribeAllRecordingFilesAsync(RecordingSession session)
{
    var results = new List<(int index, string text)>();
    int index = 0;

    foreach (var filePath in session.SessionRecordingFiles)
    {
        if (!File.Exists(filePath)) continue;

        try
        {
            byte[] audioBytes = await File.ReadAllBytesAsync(filePath);
            string text = await SpeechToText.StartFastTranscriptionWithRetry(
                audioBytes, Path.GetFileName(filePath));

            if (!string.IsNullOrWhiteSpace(text))
            {
                results.Add((index, text));
            }
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"ファイル文字起こしエラー: {ex.Message}");
            // 1つでも失敗したらエラーとして扱う
            throw;
        }
        index++;
    }

    // インデックス順に並べて結合
    return string.Join("\n", results.OrderBy(r => r.index).Select(r => r.text));
}
```

### 3.8 オフラインエラーメッセージ表示

```csharp
private async Task ShowOfflineErrorMessageAsync(RecordingSession session)
{
    await this.Dispatcher.InvokeAsync(() =>
    {
        SummaryText = "❌ インターネット接続不良のため文字起こしに失敗しました。\n\n" +
                      "インターネット接続の良好な環境で、\n" +
                      "メニュー「ファイル」→「音声ファイルから処理」から\n" +
                      "該当の音声ファイルを選択し、\n" +
                      "文字起こしと要約を行ってください。\n\n" +
                      $"📁 音声ファイル保存先:\n{session.OutputDirectory}";

        StatusText.Text = "⚠️ オフラインエラー";
        StatusText.Foreground = Brushes.Red;
    });

    // ログ記録
    LogToFile($"[オフラインエラー] SessionId: {session.SessionId}, " +
              $"ファイル数: {session.SessionRecordingFiles.Count}");
}
```

---

## 4. リトライロジックの強化（SpeechToText.cs）

### 4.1 IsTransientError の修正

```csharp
private static bool IsTransientError(Exception ex)
{
    // ネットワークエラー（接続失敗、ストリームエラー）
    if (ex.Message.Contains("sending the request") ||
        ex.Message.Contains("copying content to a stream") ||
        ex.Message.Contains("The operation was canceled") ||
        ex is TaskCanceledException ||
        ex is OperationCanceledException)
    {
        return true;
    }

    // 既存のレート制限チェック
    if (ex.Message.Contains("TooManyRequests") || ex.Message.Contains("429"))
        return true;

    if (ex is HttpRequestException httpEx)
    {
        // StatusCodeがnullの場合は接続自体が失敗
        if (httpEx.StatusCode == null)
            return true;

        return httpEx.StatusCode == HttpStatusCode.TooManyRequests ||
               httpEx.StatusCode == HttpStatusCode.ServiceUnavailable ||
               httpEx.StatusCode == HttpStatusCode.GatewayTimeout ||
               httpEx.StatusCode == HttpStatusCode.RequestTimeout;
    }

    return false;
}
```

### 4.2 リトライ間隔の上限設定

```csharp
private const int MaxRetryDelayMs = 10_000; // 最大10秒

// StartFastTranscriptionWithRetry 内のリトライ処理
delay = Math.Min(delay * 2, MaxRetryDelayMs);
```

---

## 5. 将来の拡張：音声ファイルから処理機能

### 5.1 概要
録音停止時にオフラインだった場合の救済手段として、後から音声ファイルを選択して文字起こし→要約を行う機能を追加する。

### 5.2 UI設計
- メニュー「ファイル」→「音声ファイルから処理」を追加
- ファイル選択ダイアログで音声ファイル（.wav）を選択
- 選択されたファイルを文字起こし→要約

### 5.3 実装予定
```csharp
private async void ProcessAudioFile_Click(object sender, RoutedEventArgs e)
{
    var dialog = new Microsoft.Win32.OpenFileDialog
    {
        Filter = "音声ファイル (*.wav)|*.wav",
        InitialDirectory = outputDirectory,
        Multiselect = true
    };

    if (dialog.ShowDialog() == true)
    {
        // 選択されたファイルを文字起こし
        // → 要約処理へ
    }
}
```

---

## 6. 実装順序

### Phase 1: 基盤整備
1. [ ] `TranscriptionMode` enum と状態管理フィールドの追加
2. [ ] `IsTransientError` メソッドの修正（リトライ対象拡大）
3. [ ] リトライ間隔の上限設定

### Phase 2: Unstableモード実装
4. [ ] `ProcessChunkAsync` の修正（エラー時にキュー追加＋モード切替）
5. [ ] キュー操作メソッドの追加（`AddToQueue`, `EnsureRetryTimerRunning`）
6. [ ] リトライタイマー処理の実装（`ChunkRetryTimer_Tick`）
7. [ ] Realtimeモードへの復帰処理

### Phase 3: BatchOnlyモード実装
8. [ ] `SwitchToBatchOnlyMode` メソッドの実装
9. [ ] `StopRecordingAsync` の修正（BatchOnlyモード時の処理分岐）
10. [ ] `TranscribeAllRecordingFilesAsync` メソッドの実装
11. [ ] `ShowOfflineErrorMessageAsync` メソッドの実装

### Phase 4: テスト・調整
12. [ ] ネット接続ON/OFFを繰り返してテスト
13. [ ] 10分以上オフラインのケースをテスト
14. [ ] 最後までオフラインのケースをテスト
15. [ ] メモリ使用量の確認

### Phase 5: 将来拡張（別タスク）
16. [ ] 「音声ファイルから処理」メニューの追加
17. [ ] ファイル選択→文字起こし→要約の実装

---

## 7. 技術的な注意点

### 7.1 UltraLowLoadモードとの違い
| 項目 | UltraLowLoad | BatchOnlyモード |
|------|-------------|----------------|
| 用途 | 低スペックPC対応 | ネット不安定時 |
| チャンク送信 | 5分ごとにAPI送信 | 送信しない |
| 切り替え契機 | ユーザー設定 | 自動（10分経過） |
| UI表示 | 要約のみ（文字起こしスキップ） | エラーメッセージ |
| 録音停止時 | 通常の要約処理 | ファイル全体を文字起こし |

### 7.2 メモリ使用量の見積もり
- 30秒チャンク = 約480KB (16kHz, 16bit, mono)
- 10分 = 20チャンク × 480KB = 約10MB
- 上限50チャンク = 約24MB

→ 一般的なPC（8GB RAM）で問題なし

### 7.3 順序保証
- `SortedList<DateTime, ...>` を使用してタイムスタンプ順を保証
- リトライ成功時も元のタイムスタンプを維持

---

## 8. 変更履歴への追記内容（実装完了後）

```markdown
## v○○.○ の変更
### インターネット接続不良時の対応
- **目的**: ネット不安定時でも文字起こしの抜けを防ぎ、正しい順序で結果を得られるようにする
- **実装内容**:
  - 3段階モード（Realtime → Unstable → BatchOnly）の自動切り替え
  - Unstableモード: 失敗チャンクを保持してリトライ、成功次第UI追記
  - BatchOnlyモード: 10分経過で切り替え、録音停止時に一括処理
  - オフラインエラー時の救済メッセージ表示
  - `IsTransientError` の改善（ネットワークエラーもリトライ対象に）
- **効果**:
  - 一時的な接続断でも文字起こしが失われない
  - 長時間オフラインでもメモリ枯渇を防止
  - 最終的に正しい順序で文字起こし結果を取得可能
```

---

## 9. 参考：エラーメッセージ一覧

| エラーメッセージ | 原因 | リトライ対象 |
|-----------------|------|-------------|
| `An error occurred while sending the request.` | TCP接続失敗 | ✅ Yes |
| `Error while copying content to a stream.` | 送信中に接続切断 | ✅ Yes |
| `The operation was canceled.` | タイムアウト | ✅ Yes |
| `TooManyRequests` / `429` | レート制限 | ✅ Yes |
| `ServiceUnavailable` / `503` | サービス停止 | ✅ Yes |
| `GatewayTimeout` / `504` | ゲートウェイタイムアウト | ✅ Yes |

